package codegen

import (
	"fmt"
	kubeinternal "github.com/Juminiy/kube/pkg/internal_api"
	"github.com/Juminiy/kube/pkg/log_api/stdlog"
	"github.com/Juminiy/kube/pkg/util"
	"github.com/Juminiy/kube/pkg/util/zero_reflect"
	"os"
	"reflect"
	"strconv"
	"strings"
)

// Manifest
// for all `func` of a `struct` codegen to `pkg` level func with a `pkg` level global var
type Manifest struct {
	// codegen destination file path
	// +required
	DstFilePath string

	// DstPkg must not be same with InstanceOf pkg
	// DstPkg must same with DstFilePath pkg (or suffix word)
	// +optional
	DstPkg string

	// InstanceOf only allow pointer type (Addressable type: any, func, pointer, map, slice)
	// +required
	InstanceOf any

	// +optional
	UnExportGlobalVarName string

	// +optional
	GenImport bool

	// +optional
	GenVar bool

	file     *os.File
	fileName string
	reflectType
}

func (g *Manifest) Do() {
	if len(g.DstFilePath) == 0 {
		util.SilentPanic(fmt.Errorf("DstFilePath is nil, do nothing, exit 1"))
	}
	errorOf := util.OSRemoveFile(g.DstFilePath)
	util.SilentPanic(errorOf)
	g.file, errorOf = util.OSOpenFileWithCreate(g.DstFilePath)
	util.SilentPanic(errorOf)
	_, g.fileName = g.getDstPkgAndFileName()

	if g.InstanceOf == nil {
		util.SilentPanic(fmt.Errorf("InstanceOf is nil, do nothing, exit 1"))
	}
	g.reflectType.inst = g.InstanceOf
	g.reflectType.parse()

	if len(g.UnExportGlobalVarName) == 0 {
		g.UnExportGlobalVarName = "_global" + g.typeName
	}

	// codegen comment header
	g.writes("//", "Package", g.DstPkg+kubeinternal.Slash+g.fileName, "was generated by codegen, please fix its package dependency, but do not modify its functionality").nextLine()

	g.genPackage()

	g.genImport()

	g.genVar()

	g.genFunc()
}

func (g *Manifest) genPackage() {
	g.writes("package", g.DstPkg).nextLine()
}

func (g *Manifest) genImport() {
	if g.GenImport {
		g.writes("import", "(").nextLine()
		// need to fix, maybe gofmt cmd auto fix
		g.writes(")").nextLine()
	}
}

func (g *Manifest) genVar() {
	if g.GenVar {
		g.writes("var", "(").nextLine()
		g.writes(g.UnExportGlobalVarName, g.pkgTypePtrName).nextLine()
		g.writes(")").nextLine()
		g.nextLine()
	}
}

func (g *Manifest) genFunc() {
	// for each func
	for i := range g.typ.NumMethod() {
		method := g.typ.Method(i)
		g.writes("func", method.Name, "(")

		// make a func instance and reflect func instance
		funcInstanceTypeOf := reflect.New(method.Type).Type().Elem()

		// 1. no param: must not with variable length param
		// 2. one param: if with and only if with, paramIn[0] is paramIn[last], only if
		// 3. multiple param: paramIn[last]
		withVariableLengthParam := false
		if strings.Contains(funcInstanceTypeOf.String(), "...") {
			withVariableLengthParam = true
		}

		hasParam := funcInstanceTypeOf.NumIn() > 0
		hasRetVal := funcInstanceTypeOf.NumOut() > 0

		paramList := make([]string, 0, funcInstanceTypeOf.NumIn())

		fullTypeNames := make(map[string]int, funcInstanceTypeOf.NumIn())
		// func parameter in
		for j := range funcInstanceTypeOf.NumIn() {
			paramIn := funcInstanceTypeOf.In(j)
			if j == 0 {
				continue
			}
			paramInTyp := reflectType{typ: paramIn}
			paramInTyp.parse()

			if j == funcInstanceTypeOf.NumIn()-1 && withVariableLengthParam && paramInTyp.elem != nil {
				g.writes(paramInTyp.elem.varName, "...", paramInTyp.elem.fullTypeName)
				paramList = append(paramList, paramInTyp.elem.varName)
				continue
			}

			paramInTypeId := paramInTyp.pkgTypeName
			// 1. fix example like: func fn_xxx(type_xxx1 type_xxx, type_xxx2 *type_xxx) {}, ptr type and value type conflict
			// 2. fix example like: func fn_xxx(func type_xxx, func type_xxx)
			// 3. fix example like: func fn_xxx(var_a map[string]struct{})
			paramInVarName := util.StringDelete(paramInTyp.varName, "{", "}", "[", "]", "...")
			if inTypTh, inTypExists := fullTypeNames[paramInTypeId]; inTypExists {
				paramInVarName += strconv.Itoa(inTypTh + 1)
				fullTypeNames[paramInTypeId] = inTypTh + 1
			} else {
				fullTypeNames[paramInTypeId] = 1
			}
			g.writes(paramInVarName, paramInTyp.fullTypeName)

			paramList = append(paramList, paramInVarName)
			if j < funcInstanceTypeOf.NumIn()-1 {
				g.writes(",")
			}
		}

		if !hasRetVal {
			g.writes(")", "{").nextLine()
		} else {
			g.writes(")", "(")
			// func return value out
			for j := range funcInstanceTypeOf.NumOut() {
				retValOut := funcInstanceTypeOf.Out(j)
				retValOutTyp := reflectType{typ: retValOut}
				retValOutTyp.parse()
				g.writes(retValOutTyp.fullTypeName)
				if j < funcInstanceTypeOf.NumOut()-1 {
					g.writes(",")
				}
			}
			g.writes(")", "{").nextLine()
		}

		// func body
		// call original func
		if hasRetVal {
			g.writes("return")
		}
		g.writes(g.UnExportGlobalVarName + "." + method.Name + "(")
		if hasParam {
			for k, paramRename := range paramList {
				g.writes(paramRename)
				if k < len(paramList)-1 {
					g.writes(",")
				}
				if k == len(paramList)-1 && withVariableLengthParam {
					g.writes("...")
				}
			}
		}
		g.writes(")").nextLine()

		g.writes("}").nextLine()

		g.nextLine()
	}
}

func (g *Manifest) getDstPkgAndFileName() (string, string) {
	parts := strings.Split(g.DstFilePath, kubeinternal.Slash)
	if len(parts) <= 1 {
		return g.DstPkg, parts[0]
	}
	g.DstPkg = parts[len(parts)-2]
	return g.DstPkg, parts[len(parts)-1]
}

func (g *Manifest) write(s string) *Manifest {
	_, err := g.file.WriteString(s)
	util.SilentPanic(err)
	_, err = g.file.WriteString(" ")
	util.SilentPanic(err)
	return g
}

func (g *Manifest) writes(s ...string) *Manifest {
	for _, elem := range s {
		g.write(elem)
	}
	return g
}

func (g *Manifest) nextLine() *Manifest {
	_, err := g.file.WriteString("\n")
	util.SilentPanic(err)
	return g
}

type reflectType struct {
	inst any
	typ  reflect.Type

	// src pkg name with generate pkg name
	comparePkgName string

	// current pkg name
	pkgName string
	// current pkg short name
	shortPkg string

	// full type name, with ptr(if absent), with package(must absent)
	fullTypeName string
	// type name with package
	pkgTypeName string
	// type ptr name with package
	pkgTypePtrName string
	// type name, pure name without package
	typeName string
	// type ptr name, pure name without package
	typePtrName string

	varName string

	// only for variable length param
	isElem bool
	elem   *reflectType
}

func (t *reflectType) parse() {
	if t.inst != nil {
		t.typ = zero_reflect.TypeOf(t.inst)
	}
	if t.typ == nil {
		stdlog.Error("nil typ either elem nor none-elem")
		return
	}

	t.pkgName, t.typeName = splitPkgType(t.typ.String())
	t.shortPkg = getLastSlash(t.pkgName)

	// pkg1/pkg2/pkg3/example.ExampleStruct
	// *pkg1/pkg2/pkg3/example.ExampleStruct
	// pkg1/pkg2/pkg3/*example.ExampleStruct

	t.fullTypeName = t.typ.String()
	// must differ slice and variable-length param
	if t.typ.Kind() == reflect.Slice {
		t.elem = &reflectType{typ: t.typ.Elem(), isElem: true}
		t.elem.parse()
	}

	t.pkgTypeName = getLastSlash(strings.ReplaceAll(t.fullTypeName, "*", ""))

	t.pkgTypePtrName = "*" + t.pkgTypeName
	t.typePtrName = "*" + t.typeName

	// +example1: Type_xxx -> type_xxx
	// +example2: type_xxx -> _type_xxx
	// +example3: func -> _func, const -> _const
	if typeName0IsLower,
		typeNameIsGoKeyword :=
		strings.ToLower(string(t.typeName[0])) == string(t.typeName[0]),
		util.MapOk(goWordMap, t.typeName); typeName0IsLower || typeNameIsGoKeyword {
		t.varName = "_" + t.typeName
	} else {
		t.varName = strings.ToLower(string(t.typeName[0])) + t.typeName[1:]
	}

	t.varName = util.StringReplaceAlls(t.varName, "", "(", ")", "[", "]")

	if t.isElem {
		t.varName = "varLen" + t.varName
	}
}

func getLastSlash(s string) string {
	parts := strings.Split(s, kubeinternal.Slash)
	if len(parts) == 0 {
		return ""
	}
	return parts[len(parts)-1]
}

func splitPkgType(s string) (string, string) {
	s = strings.ReplaceAll(s, "*", "")
	parts := strings.Split(s, ".")
	if len(parts) == 0 {
		return "", ""
	} else if len(parts) == 1 {
		return "", parts[0]
	}
	return parts[len(parts)-2], parts[len(parts)-1]
}

type reflectValue struct {
	inst any
	val  reflect.Value
}

func (v *reflectValue) parse() {

}
